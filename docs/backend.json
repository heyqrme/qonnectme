{
  "entities": {
    "UserProfile": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserProfile",
      "type": "object",
      "description": "Represents a user's profile within the Qonnectme application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user profile."
        },
        "qrCode": {
          "type": "string",
          "description": "The user's unique QR code string."
        },
        "personalInformation": {
          "type": "string",
          "description": "User's personal information like bio or contact details."
        },
        "profileThemeId": {
          "type": "string",
          "description": "Reference to ProfileTheme. (Relationship: UserProfile 1:1 ProfileTheme)"
        },
        "photoIds": {
          "type": "array",
          "description": "References to Photos. (Relationship: UserProfile 1:N Photo)",
          "items": {
            "type": "string"
          }
        },
        "videoIds": {
          "type": "array",
          "description": "References to Videos. (Relationship: UserProfile 1:N Video)",
          "items": {
            "type": "string"
          }
        },
        "musicIds": {
          "type": "array",
          "description": "References to Musics. (Relationship: UserProfile 1:N Music)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "qrCode"
      ]
    },
    "FriendRequest": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FriendRequest",
      "type": "object",
      "description": "Represents a friend request between two users.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the friend request."
        },
        "senderId": {
          "type": "string",
          "description": "Reference to UserProfile who sent the request. (Relationship: UserProfile 1:N FriendRequest)"
        },
        "receiverId": {
          "type": "string",
          "description": "Reference to UserProfile who received the request. (Relationship: UserProfile 1:N FriendRequest)"
        },
        "status": {
          "type": "string",
          "description": "Status of the friend request (e.g., pending, accepted, rejected)."
        }
      },
      "required": [
        "id",
        "senderId",
        "receiverId",
        "status"
      ]
    },
    "Photo": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Photo",
      "type": "object",
      "description": "Represents a photo uploaded by a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the photo."
        },
        "userId": {
          "type": "string",
          "description": "Reference to UserProfile who uploaded the photo. (Relationship: UserProfile 1:N Photo)"
        },
        "url": {
          "type": "string",
          "description": "URL of the photo."
        },
        "uploadDate": {
          "type": "string",
          "description": "Date and time when the photo was uploaded.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "url",
        "uploadDate"
      ]
    },
    "Video": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Video",
      "type": "object",
      "description": "Represents a video uploaded by a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the video."
        },
        "userId": {
          "type": "string",
          "description": "Reference to UserProfile who uploaded the video. (Relationship: UserProfile 1:N Video)"
        },
        "url": {
          "type": "string",
          "description": "URL of the video."
        },
        "uploadDate": {
          "type": "string",
          "description": "Date and time when the video was uploaded.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "url",
        "uploadDate"
      ]
    },
    "Music": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Music",
      "type": "object",
      "description": "Represents a music track uploaded or linked by a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the music track."
        },
        "userId": {
          "type": "string",
          "description": "Reference to UserProfile who uploaded the music. (Relationship: UserProfile 1:N Music)"
        },
        "url": {
          "type": "string",
          "description": "URL of the music track."
        },
        "uploadDate": {
          "type": "string",
          "description": "Date and time when the music was uploaded.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "url",
        "uploadDate"
      ]
    },
    "StoreItem": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StoreItem",
      "type": "object",
      "description": "Represents an item available in the QR code merchandise store.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the store item."
        },
        "name": {
          "type": "string",
          "description": "Name of the store item."
        },
        "description": {
          "type": "string",
          "description": "Description of the store item."
        },
        "price": {
          "type": "number",
          "description": "Price of the store item."
        },
        "imageUrl": {
          "type": "string",
          "description": "URL of the store item's image."
        }
      },
      "required": [
        "id",
        "name",
        "description",
        "price",
        "imageUrl"
      ]
    },
    "ProfileTheme": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ProfileTheme",
      "type": "object",
      "description": "Represents a theme for a user's profile, potentially generated by AI.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the profile theme."
        },
        "name": {
          "type": "string",
          "description": "Name of the theme."
        },
        "primaryColor": {
          "type": "string",
          "description": "Primary color of the theme."
        },
        "secondaryColor": {
          "type": "string",
          "description": "Secondary color of the theme."
        },
        "font": {
          "type": "string",
          "description": "Font used in the theme."
        }
      },
      "required": [
        "id",
        "name",
        "primaryColor",
        "secondaryColor",
        "font"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "UserProfile",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "Collection to store user profiles. The 'userId' is obtained from 'request.auth.uid'.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user. It comes from request.auth.uid"
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/profiles/{profileId}",
        "definition": {
          "entityName": "UserProfile",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "Subcollection to store individual user profiles. Path-based rules secure access.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "profileId",
              "description": "The unique identifier for the user profile."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/photos/{photoId}",
        "definition": {
          "entityName": "Photo",
          "schema": {
            "$ref": "#/backend/entities/Photo"
          },
          "description": "Subcollection to store user-uploaded photos. Path-based rules ensure that only the user can access their own content.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "photoId",
              "description": "The unique identifier for the photo."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/videos/{videoId}",
        "definition": {
          "entityName": "Video",
          "schema": {
            "$ref": "#/backend/entities/Video"
          },
          "description": "Subcollection to store user-uploaded videos. Path-based rules ensure that only the user can access their own content.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "videoId",
              "description": "The unique identifier for the video."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/music/{musicId}",
        "definition": {
          "entityName": "Music",
          "schema": {
            "$ref": "#/backend/entities/Music"
          },
          "description": "Subcollection to store user-uploaded music. Path-based rules ensure that only the user can access their own content.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "musicId",
              "description": "The unique identifier for the music."
            }
          ]
        }
      },
      {
        "path": "/friend_requests/{friendRequestId}",
        "definition": {
          "entityName": "FriendRequest",
          "schema": {
            "$ref": "#/backend/entities/FriendRequest"
          },
          "description": "Collection to store friend requests. 'senderId' and 'receiverId' fields are used to determine access.",
          "params": [
            {
              "name": "friendRequestId",
              "description": "The unique identifier for the friend request."
            }
          ]
        }
      },
      {
        "path": "/store_items/{storeItemId}",
        "definition": {
          "entityName": "StoreItem",
          "schema": {
            "$ref": "#/backend/entities/StoreItem"
          },
          "description": "Collection to store items available in the store. These are globally readable and writable only by admins (enforced via a separate `/roles_admin/{uid}` collection).",
          "params": [
            {
              "name": "storeItemId",
              "description": "The unique identifier for the store item."
            }
          ]
        }
      },
      {
        "path": "/profile_themes/{profileThemeId}",
        "definition": {
          "entityName": "ProfileTheme",
          "schema": {
            "$ref": "#/backend/entities/ProfileTheme"
          },
          "description": "Collection to store themes available to users. These are globally readable, but create/update permissions are restricted to admins.",
          "params": [
            {
              "name": "profileThemeId",
              "description": "The unique identifier for the profile theme."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "UserProfile",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "An existence-based collection to grant admin privileges. If a document exists for a 'userId' here, the user is considered an admin.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user with admin privileges."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to ensure security, scalability, and ease of debugging, adhering to the core design principles of Authorization Independence, Clarity of Intent, DBAC (Database-Based Access Control), and QAPs (Rules are not Filters). Authorization independence is achieved through denormalization.  Specifically, for collaborative data (if any), membership maps (`members: {uid1: \"role\", uid2: \"role\"}`) will be denormalized where needed to avoid `get()` calls in security rules.  Structural Segregation is applied by grouping documents with similar security requirements into the same collections (e.g., user-owned data under `/users/{userId}`). Access modeling follows the principle of path-based ownership for private data (e.g., `/users/{userId}/profiles/{profileId}`).\n\n*   `/users/{userId}`: This collection stores user-related data, primarily for authentication context. The `userId` is obtained from `request.auth.uid`. Subcollections will contain private user data.\n*   `/users/{userId}/profiles/{profileId}`: Stores individual user profiles. The `profileId` is a unique identifier for each profile. Path-based rules secure access.\n*   `/users/{userId}/photos/{photoId}`, `/users/{userId}/videos/{videoId}`, `/users/{userId}/music/{musicId}`: Stores user-uploaded multimedia content. Path-based rules ensure that only the user can access their own content.\n*   `/friend_requests/{friendRequestId}`: Stores friend requests.  `senderId` and `receiverId` fields are used to determine access. Denormalization isn't needed here because rules will only enforce that a user can only create requests where they are the sender or receiver, or update requests where they are the receiver (accept/reject).\n*   `/store_items/{storeItemId}`: Stores items available in the store.  These are globally readable and writable only by admins (enforced via a separate `/roles_admin/{uid}` collection).\n*   `/profile_themes/{profileThemeId}`: Stores themes available to users. These are globally readable, but create/update permissions are restricted to admins.\n*   `/roles_admin/{userId}`: An existence-based collection to grant admin privileges. If a document exists for a `userId` here, the user is considered an admin.\n\nThis design supports QAPs. List operations are secured because each collection has a well-defined access pattern based on ownership or global roles. Authorization independence is achieved by avoiding `get()` calls and denormalizing membership where necessary.  The structure promotes clear and maintainable security rules."
  }
}